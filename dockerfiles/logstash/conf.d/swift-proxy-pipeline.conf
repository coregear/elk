input {
  #stdin {
    #tags => ["stdin"]
  #}
  lumberjack {
    port => "5043"
    ssl_certificate => "/certs/logstash-forwarder-prod.crt"
    ssl_key => "/certs/logstash-forwarder-prod.key"
    tags => ["lumberjack"]
  }
}
filter {
  #if "stdin" not in [tags] {
    #drop {}
  #}
  if "lumberjack" not in [tags] {
    drop {}
  }

  # skipping unrelavant logs
  if [message] =~ "authtoken: Invalid user token - deferring reject downstream" or
     [message] !~ "proxy-server: " {
    drop {}
  }

  grok {
    match => { "message" => "%{SYSLOGTIMESTAMP:log_timestamp} (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource} %{SYSLOGPROG}: (%{IPORHOST:client_ip}|-) (%{IPORHOST:remote_addr}|-) (?:%{MONTHDAY}/%{MONTH}/%{YEAR}/%{HOUR}/%{MINUTE}/%{SECOND}) %{WORD:request_method} %{NOTSPACE:request_path} %{NOTSPACE:protocol} %{NUMBER:status_code} (%{NOTSPACE:referer}|-) (%{NOTSPACE:user_agent}|-) (%{NOTSPACE:authtoken}|-) (%{NUMBER:bytes_recvd:int}|-) (%{NUMBER:bytes_sent:int}|-) (%{NOTSPACE:etag}|-) %{NOTSPACE:txnid} (%{NOTSPACE:headers}|-) %{NUMBER:duration:float} (%{NOTSPACE:source}|-) (%{NOTSPACE:log_info}|-) %{NUMBER:request_start_time:float} %{NUMBER:request_end_time:float}" }
  }

  date { match => ["request_start_time", "UNIX"] }

  # request_path post processing
  urldecode { field => "request_path" }
  grok {
    match => { "request_path" => "/%{WORD:api_version}/%{WORD:account}/%{BUCKET:container}(/%{OBJECT:object})?%{URIPARAM:uriparam}?" }
  }

  # useragent post processing
  urldecode { field => "user_agent" }
  if [user_agent] and [user_agent] != "-" {
      useragent {
        prefix => "ua_"
        source => "user_agent"
      }
  }

  # post processing
  urldecode { field => "object" }
  if [object] {
      ruby { code => "event['object_nested_level'] = event['object'].count('/')" }
  }

  # calculate kbps
  if [bytes_sent] and [bytes_recvd] {
      mutate { add_tag => [ "error" ] }
  }
  if [bytes_sent] and [duration] {
      ruby {
        code => "event['kilobytes_sent'] = event['bytes_sent'].to_f / 1024
                 event['bps_sent'] = event['bytes_sent'].to_f / event['duration'].to_f
                 event['kbps_sent'] = event['bps_sent'].to_f / 1024"
      }
  } else if [bytes_recvd] and [duration] {
      ruby {
        code => "event['kilobytes_recvd'] = event['bytes_recvd'].to_f / 1024
                 event['bps_recvd'] = event['bytes_recvd'].to_f / event['duration'].to_f
                 event['kbps_recvd'] = event['bps_recvd'].to_f / 1024"
      }
  }

  # wrapup
  if "_grokparsefailure" in [tags] {
      mutate {
        add_tag => [ "unknown" ]
        remove_tag => [ "_grokparsefailure" ]
      }
  }

  # metrics
  #metrics {
    #meter             => ['response.status_code.%{status_code}', 'request.method.%{request_method}']
    ## set it larger than Graphite interval or else will losing data
    #flush_interval    => 10
    #clear_interval    => 10
    ## disable rates measurement, cause anyway it's working correctly with clear_interval
    #rates             => []
    ## for debug
    #ignore_older_than => 0
    #add_tag           => "metrics"
  #}
}
output {
  #stdout { codec => rubydebug }
  elasticsearch {
    hosts => ["elasticsearch"]
    index => "swift-proxy-%{+YYYY.MM.dd}"
    template => "/etc/logstash/conf.d/swift-proxy-template.json"
    template_name => "template_swift_proxy"
    template_overwrite => true
  }
}
